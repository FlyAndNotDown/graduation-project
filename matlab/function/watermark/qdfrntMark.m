function output = qdfrntMark(source, secret, ks, kt, ikt, intensity)
%qdfrntMark - add watermark to a picture
%
% - Description:
%       add a watermark to picture, with QDFRNT function
%
% - Arguments:
%       - source [nxnx3 double matrix] matrix of colorful source image
%       - secret [mxm binary matrix] matrix of binary secret image
%       - ks [integer] a key of watermarking, the times of secret arnold transform
%       - kt [8x8 double matrix] kernel matrix of transform, can be generated by function 'dfrntKernel'
%       - ikt [8x8 double matrix] the kernel matrix which is used to restored transform
%       - intensity [double] the intensity of watermarking
%
% - Returns:
%       - output [nxnx3 double matrix] output matrix

% get size info
[sourceRow, sourceCol, sourceHeight] = size(source);

% do arnold transform to secret
secretArnold = arnold(secret, ks);

% get binary secret sequence
secretSequence = matrixToVector(secretArnold);
[~, secretSequenceLength] = size(secretSequence);

% split picture to 8x8 smaller blocks
blocks = splitBlock(source, 8);
[~, blocksLength] = size(blocks);
[blockRow, blockCol, blockHeight] = size(blocks{1, 1});

% set a pure unit quaternion
u = [0, 1, 0, 0];

% do QDFRNT to every blocks
encodedBlocks = cell(1, blocksLength);
for n = 1 : blocksLength
    [blockRow, blockCol, blockHeight] = size(blocks{1, n});
    t = zeros(blockRow, blockCol, blockHeight + 1);
    for n1 = 2 : 4
        t(:, :, n1) = blocks{1, n}(:, :, n1 - 1);
    end
    encodedBlocks{1, n} = lqdfrnt2(t, kt, kt, u);
end

% get adaptive factor of every block
adaptiveFactors = adaptiveFactor(blocks, 1);

% % add some info
% for n = 1 : blocksLength
%     encodedBlocks{1, n}(1, 1, 3) = encodedBlocks{1, n}(1, 1, 3) + 0.2;
% end

% restoredBlocks = cell(1, blocksLength);
% for n = 1 : blocksLength
%     restoredBlocks{1, n} = lqdfrnt2(encodedBlocks{1, n}, ikt, ikt, u);
%     restoredBlocks{1, n} = restoredBlocks{1, n}(:, :, [2, 3, 4]);
% end

% output = mergeBlock(restoredBlocks, fix(sourceCol / 8));

% sort with order 'adpadtiveFactor'
adaptiveFactorsWithPosition = cell(1, blocksLength);
for n = 1 : blocksLength
    adaptiveFactorsWithPosition{1, n} = zeros(1, 2);
    adaptiveFactorsWithPosition{1, n}(1, 1) = n;
    adaptiveFactorsWithPosition{1, n}(1, 2) = adaptiveFactors(1, n);
end

% select all blocks where 'adaptiveFactor' == 2 || 'adaptiveFactor' == 3
x = 1;
n = 1;
while n <= blocksLength
    marked = false;
    if x > secretSequenceLength
        break;
    end
    f = adaptiveFactorsWithPosition{1, n}(1, 2);
    if f == 2 || f == 3
        blockPosition = adaptiveFactorsWithPosition{1, n}(1, 1);
        % start watermarking
        for n1 = 1 : blockRow
            for n2 = 1 : blockCol
                average = 0;
                for n3 = -1 : 1
                    for n4 = -1 : 1
                        row = n1 + n3;
                        col = n2 + n4;
                        if row >= 1 && row <= blockRow && col >= 1 && col <= blockCol
                            average = average + encodedBlocks{1, blockPosition}(row, col);
                        end 
                    end
                end
                average = (average - encodedBlocks{1, blockPosition}(n1, n2)) / 8;
                encodedBlocks{1, blockPosition}(n1, n2, 3) = average + (2 * secretSequence(1, x) - 1) * f * intensity;
                marked = true;
            end
        end
    end
    if marked
        x = x + 1;
        n = n + 50;
    else
        n = n + 1;
    end
end

% do ILQDFRNT to every blocks
for n = 1 : blocksLength
    encodedBlocks{1, n} = lqdfrnt2(encodedBlocks{1, n}, ikt, ikt, u);
    encodedBlocks{1, n} = encodedBlocks{1, n}(:, :, [2, 3, 4]);
end

% merge
output = mergeBlock(encodedBlocks, fix(sourceRow / blockRow));

end